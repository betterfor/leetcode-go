### 1、孤儿进程，僵尸进程
- 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将会成为孤儿进程。
孤儿进程会被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
- 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，
那么子进程的进程描述符仍保存在系统中。

**问题和危害**

unix提供一种机制可以保证父进程想知道子进程结束的状态信息，就可以得到的机制为：
在每个进程退出时，内核释放进程所有的资源，包括打开的文件、占用的内存等，但仍保留一定的信息(包括process ID，退出状态，运行时间等)，
直到父进程通过wait/waitpid来取时才释放。
（如果不调用wait/waitpid，保留的信息不会释放，进程号会被一直占用，但是系统所能使用的进程号有限，如果大量产生僵死进程，
将会因为没有可用的进程号而导致系统不能产生新的进程）

孤儿进程是没有父进程的进程，由init进程循环的wait回收资源，init充当父进程。因此父进程没有什么危害。

**僵尸进程的预防**
- 子进程退出时向父进程发出sigchld信号，父进程处理sigchld信号，在信号处理时调用wait处理僵尸进程
- fork两次，将子进程变成孤儿进程，从而其父进程变为init进程

**僵尸进程的处理**
- 杀死僵尸进程的父进程，使僵尸进程成为孤儿进程

**守护进程**
一种特殊的孤儿进程。守护进程*脱离终端会话的影响运行在后台，从被执行开始运转知道整个系统关闭时才退出*。

*具体实现方式*
1、创建子进程，退出父进程(在形式上做到与控制终端的脱离)
2、使用setsid在子进程中创建新的会话(`setid`可以让进程摆脱原会话，进程组，控制终端的控制，使进程完全独立)
3、改变工作目录(子进程继承父进程的工作目录，由于在进程运行过程中，当前目录所在的文件系统不能卸载，不方便，会将根目录设置成守护进程的工作目录`chdir`)
4、重设文件权限掩码(`屏蔽文件创建时的对应位`,将文件权限掩码设置成0`umask(0)`)
5、关闭文件描述符(子进程继承父进程已经打开的文件，这些文件可能不会被守护进程读写，但一样在消耗系统资源，所以`文件描述符为0、1、2`的3个文件已经失去意义(输入、输出、报错)应该关掉)
6、梳理sigchild信号(`signal(SIGCHLD,SIG_IGN)`使父进程等待子进程退出，这样内核在子进程结束时不会产生僵尸进程)

**参考连接**
[孤儿进程和僵尸进程](https://www.cnblogs.com/Anker/p/3271773.html)
[守护进程](https://blog.csdn.net/Outtch_/article/details/105276364)

### 2、死锁条件，如何避免
死锁是指多个进程因竞争资源而造成的一种僵局(互相等待)。

**死锁产生的原因**
1、系统资源的竞争
2、进程运行的推送顺序不合适(请求和释放资源的顺序不当)

**死锁的四个必要条件**
互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待。

请求与保持条件：进程已经保持至少一个资源，但又提出了新的资源请求，而新资源已被其他进程占有，此时请求被阻塞，但对自己已获得的资源保持不放。

不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强制夺走，即只能由该资源的进程自己释放(只能是主动释放)。

循环等待条件：若干进程间形成首位相接循环等待资源的关系。

*这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。*

**死锁预防**
1、破坏不可剥夺条件：一个进程已经持有的一些资源在提出新的资源请求没有响应时，必须释放已经保持的所有资源，待以后需要使用时再重新申请。
2、破坏请求与保持条件：所有进程在运行之前必须一次性申请在其运行过程中所需要的全部资源(缺点：会使进程发生饥饿现象)；
只申请运行初期的资源，在运行过程中逐步释放分配的已经使用完的资源，再去请求新资源。
3、破坏循环等待条件：将系统中的资源顺序编号，将稀少的采用较大编号，申请资源时按编号顺序进行。

**死锁避免**
1、系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，
如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。
2、银行家算法 

**参考链接**

[死锁](https://blog.csdn.net/guaiguaihenguai/article/details/80303835)

[银行家算法](https://www.cnblogs.com/chuxiuhong/p/6103928.html)

### 3、linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程

### 4、git文件版本，使用顺序，merge跟rebase

### 5、select、epoll的原理

### 6、怎么查看一个程序是否正常运行？端口为801

### 7、怎么查找一个文件

### 8、怎么查找一个字符串，在哪些文件中

### 9、top命令信息解读

### 10、5种IO模型
[](https://www.jianshu.com/p/486b0965c296)

## 11、内存管理
[](https://www.linuxprobe.com/programmer-must-read%EF%BC%9A-linux-memory-management.html)

## 12、线程调度
[](https://www.cnblogs.com/leisure_chn/p/10393707.html)


## 13、进程、线程、协程
内核态，用户态，上下文切换，栈空间管理

## 14、Reactor设计模式