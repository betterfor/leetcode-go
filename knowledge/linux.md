### 1、孤儿进程，僵尸进程
- 孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将会成为孤儿进程。
孤儿进程会被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
- 僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程没有调用wait或waitpid获取子进程的状态信息，
那么子进程的进程描述符仍保存在系统中。

**问题和危害**

unix提供一种机制可以保证父进程想知道子进程结束的状态信息，就可以得到的机制为：
在每个进程退出时，内核释放进程所有的资源，包括打开的文件、占用的内存等，但仍保留一定的信息(包括process ID，退出状态，运行时间等)，
直到父进程通过wait/waitpid来取时才释放。
（如果不调用wait/waitpid，保留的信息不会释放，进程号会被一直占用，但是系统所能使用的进程号有限，如果大量产生僵死进程，
将会因为没有可用的进程号而导致系统不能产生新的进程）

孤儿进程是没有父进程的进程，由init进程循环的wait回收资源，init充当父进程。因此父进程没有什么危害。

**僵尸进程的预防**
- 子进程退出时向父进程发出sigchld信号，父进程处理sigchld信号，在信号处理时调用wait处理僵尸进程
- fork两次，将子进程变成孤儿进程，从而其父进程变为init进程

**僵尸进程的处理**
- 杀死僵尸进程的父进程，使僵尸进程成为孤儿进程

**守护进程**
一种特殊的孤儿进程。守护进程*脱离终端会话的影响运行在后台，从被执行开始运转知道整个系统关闭时才退出*。

*具体实现方式*
1、创建子进程，退出父进程(在形式上做到与控制终端的脱离)
2、使用setsid在子进程中创建新的会话(`setid`可以让进程摆脱原会话，进程组，控制终端的控制，使进程完全独立)
3、改变工作目录(子进程继承父进程的工作目录，由于在进程运行过程中，当前目录所在的文件系统不能卸载，不方便，会将根目录设置成守护进程的工作目录`chdir`)
4、重设文件权限掩码(`屏蔽文件创建时的对应位`,将文件权限掩码设置成0`umask(0)`)
5、关闭文件描述符(子进程继承父进程已经打开的文件，这些文件可能不会被守护进程读写，但一样在消耗系统资源，所以`文件描述符为0、1、2`的3个文件已经失去意义(输入、输出、报错)应该关掉)
6、梳理sigchild信号(`signal(SIGCHLD,SIG_IGN)`使父进程等待子进程退出，这样内核在子进程结束时不会产生僵尸进程)

**参考连接**
[孤儿进程和僵尸进程](https://www.cnblogs.com/Anker/p/3271773.html)
[守护进程](https://blog.csdn.net/Outtch_/article/details/105276364)

### 2、死锁条件，如何避免
死锁是指多个进程因竞争资源而造成的一种僵局(互相等待)。

**死锁产生的原因**
1、系统资源的竞争
2、进程运行的推送顺序不合适(请求和释放资源的顺序不当)

**死锁的四个必要条件**
互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待。

请求与保持条件：进程已经保持至少一个资源，但又提出了新的资源请求，而新资源已被其他进程占有，此时请求被阻塞，但对自己已获得的资源保持不放。

不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强制夺走，即只能由该资源的进程自己释放(只能是主动释放)。

循环等待条件：若干进程间形成首位相接循环等待资源的关系。

*这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。*

**死锁预防**
1、破坏不可剥夺条件：一个进程已经持有的一些资源在提出新的资源请求没有响应时，必须释放已经保持的所有资源，待以后需要使用时再重新申请。
2、破坏请求与保持条件：所有进程在运行之前必须一次性申请在其运行过程中所需要的全部资源(缺点：会使进程发生饥饿现象)；
只申请运行初期的资源，在运行过程中逐步释放分配的已经使用完的资源，再去请求新资源。
3、破坏循环等待条件：将系统中的资源顺序编号，将稀少的采用较大编号，申请资源时按编号顺序进行。

**死锁避免**
1、系统对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，
如果分配后系统可能发生死锁，则不予分配，否则予以分配，这是一种保证系统不进入死锁状态的动态策略。
2、银行家算法 

**参考链接**

[死锁](https://blog.csdn.net/guaiguaihenguai/article/details/80303835)

[银行家算法](https://www.cnblogs.com/chuxiuhong/p/6103928.html)

### 3、linux命令，查看端口占用，cpu负载，内存占用，如何发送信号给一个进程

- netstat：

用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用来校验本机各端口的网络连接情况。

`-t`：TCP；`-u`：UDP；`-l`：listening；

- top：显示当前系统正在运行的进程的相关信息，包括进程ID、内存占用率、cpu占用率等

- kill：用来终止一个进程，向linux系统的内核发送一个系统操作信号和某个进程标记号，然后系统内核就能对进程标记号指定的进程进行操作。

1 终端断线；2中断；3退出；9强制停止；15终止；18继续；19暂停

### 4、git merge和rebase区别

- git commit会按照提交的时间来排列
- git rebase基于原分支提交点后commit重新生成一个新的commit hash值

### 5、同步、异步、阻塞与非阻塞，IO的五种模型

- 同步：一个任务的完成需要依赖另一个任务时，只有等待的任务完成后，依赖的任务才能完成，这是一种可靠的任务序列
- 异步：不需要等待被依赖的任务完成，只是通知被依赖的服务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就完成了。至于被依赖的任务是否真正完成，依赖他的任务无法确定，所以是不可靠序列。

- 阻塞和非阻塞：调用结果返回之前，当前进程等待调用结果的状态

---
1、用户态和内核态：为了保护用户进程不能直接操作内核，保护内核安全，一部分为内核空间，一部分是用户空间。

2、内核切换：为了控制内核的执行，内核可以挂起正在cpu执行的进程，并恢复之前挂起的某个进程执行。但是内核切换需要保存上下文信息，包括程序计数器和其他寄存器等，很消耗资源。

3、进程阻塞：当进程进入阻塞状态时，是不占用cpu资源的。

**IO模型**

- 同步阻塞IO：用户态执行一个系统调用，会导致应用程序阻塞，直到调用完成，将数据从内核复制到用户进程，最后进程再处理用户数据。在等待数据和处理数据的两个阶段，整个进程都被阻塞，不能进行其他IO

![同步阻塞IO](https://gitee.com/zongl/cloudImage/raw/master/images/2021/03/02/同步阻塞IO.png)

* 优点：能够及时返回数据，无延迟；
* 缺点：对用户来说需要等待

- 同步非阻塞IO：用户态执行一个系统调用，进程并没有阻塞，内核会返回进程，如果数据没有准备好会返回error。进程可以*轮询*内核数据，直到数据完成，再拷贝数据。

![同步非阻塞](https://gitee.com/zongl/cloudImage/raw/master/images/2021/03/02/同步非阻塞.png)

* 优点：能够在等待时间处理其他任务
* 缺点：任务完成的响应延迟增加，因为需要轮询，而任务可能在两次轮询之间完成，会降低数据吞吐量

- IO多路复用：由于轮询需要占用大量cpu时间，所以IO复用模型会用到select\poll\epoll函数，能够处理多个连接

![多路复用](https://gitee.com/zongl/cloudImage/raw/master/images/2021/03/02/多路复用IO.png)

- 信号驱动式IO：通过在信号处理函数中调用IO操作

![信号驱动IO](https://gitee.com/zongl/cloudImage/raw/master/images/2021/03/02/信号驱动IO.png)

- 异步IO：用户态系统调用后，会去做其他任务，当数据准备好后，从内核向进程发送通知

![异步IO](https://gitee.com/zongl/cloudImage/raw/master/images/2021/03/02/异步IO.png)

![五种IO模型比较](https://gitee.com/zongl/cloudImage/raw/master/images/2021/03/02/五种IO模型比较.png)

[Linux五种IO模型](https://www.jianshu.com/p/486b0965c296)

### 6、select、poll，epoll的原理

select、poll，epoll本质上都是同步IO，因为他们都需要在读写事件就绪后自己负责读写，也就是说这个读写是阻塞的。

- select：无差别轮询所有的流，找出能独处数据或者写入数据的流。（通过设置和检查存放fd标志位的数据结构来进行下一步处理）
 * 缺点：单个进程可监视的fd数量被限制，即能监听的端口大小有限；对socket进行扫描时是线性扫描，采用轮询的方式，效率很低；需要维护一个存放大量fd的数据结构，会使用户态和内核态在传递时开销大。
- poll：将用户态转为内核态，检查每个fd对应的设备状态，但没有最大连接数的限制，是因为底层是基于链表实现的
 * 缺点：大量的fd被数组整体复制与用户态和内核态之间；如果报告fd没有处理，下一次还会报告fd
- epoll：通过事件通知，对于文件描述符有两种操作模式：LT（level trigger）和ET（edge trigger）
 * LT：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理，下次调用epoll_wait时，会再次响应应用程序并通知事件。（默认）
 * ET：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理。如果不处理，下次再调用epoll_wait时，不会再响应应用程序并通知此事件。（效率更高）

**总结**

|                                  | select                       | poll                         | epoll                  |
| -------------------------------- | ---------------------------- | ---------------------------- | ---------------------- |
| 支持一个进程所能打开的最大连接数 | 最大定义                     | 没有最大限制，用链表存储     | 有上限，但很大         |
| fd增加后的IO效率                 | 因为线性遍历，效率变慢       | 因为线性遍历，效率变慢       | 不会下降               |
| 消息传递方式                     | 内核态到用户态，需要内核拷贝 | 内核态到用户态，需要内核拷贝 | 内核和用户共享一块内存 |

[select、poll，epoll的区别](https://www.cnblogs.com/aspirant/p/9166944.html)

### 7、怎么查找一个文件

- find: 通过搜索整个目录树查询文件
- locate：在数据库中查找文件

### 8、怎么查找一个字符串，在哪些文件中

- grep -rn "str"

*:表示当前目录所有文件

-r：递归查找

-n：显示行号

-R：查找所有文件包括子目录

-i：忽略大小写

### 9、内存管理



[](https://www.linuxprobe.com/programmer-must-read%EF%BC%9A-linux-memory-management.html)

### 10、线程调度
       [](https://www.cnblogs.com/leisure_chn/p/10393707.html)

## 11、Reactor设计模式


## 12、线程的五种状态
- 新建
- 就绪
- 运行
- 阻塞
- 死亡

## 13、top命令和ctop

