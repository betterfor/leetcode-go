### 1、为什么redis这么快？
- 单线程
- 强大的底层数据结构
- 基于内存

### 2、redis可变字符串和跳表的原理？

### 3、加入redis里有1亿个key，其中10w个key是以某个固定的前缀开头，如何把他们全部找出来？
使用keys命令可以扫描出指定模式的key列表，但由于redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。
可以使用scan指令可以无阻塞去除指定模式的key列表，但可能会有重复，需要在客户端去重，整体花费时间大于keys。

### 4、redis缓存穿透，击穿，雪崩

### 5、redis的数据结构
- 字符串string
- 字典hash
- 列表list
- 集合set
- 有序集合sortedsort

### 6、redis对比memcached有哪些优势？
- memcached所有值均是简单字符串，redis有更丰富的数据结构
- redis的速度比memcached快很多
- redis可以持久化数据

### 7、redis的持久化方案
**全量持久化RDB** (`dump.rdb`)

按照一定的时间周期将目前服务中所有的数据全部写入磁盘。
在操作过程中，主线程会fork一个线程专门用来拷贝，
而这段时间的数据变化会以副本的方式存放在一个内存区域，在快照操作完成后同步到原来的内存区域。

*命令*
手动执行 save/bgsave

或配置 save <seconds> <changes> (在多少秒内有多少key信息发生变化，则进行快照)

**优势**
- rdb是redis数据非常紧凑的单文件时间点，非常适合备份
- rdb对于灾难恢复非常有用
- rdb最大限度提高redis的性能，父进程不会执行磁盘I/O操作
- 与aof相比，rdb允许大型数据集更快重启

**缺点**
- 在redis处于任何原因没有在正确关闭下停止工作，会丢失数据
- rdb需要经常fork子进程，如果数据集很大，fork操作会很耗时，如果数据集大并且cpu性能不佳，会导致redis停止

**增量持久化AOF**

配置文件中 `appendonly yes`

每次redis收到更改数据集时都会添加到aof。每次重启redis时，都会重新播放aof以重建状态。

可以猜想到，随着写操作越来越多，aof越来越大，redis为aof提供重写aof功能，保证aof可以存储尽可能少的操作命令就能保证数据恢复到最新状态。

**优势**
- 更加持久：可以采用不同的fsync策略：always(每个写操作)、everysec(每秒，默认值)、no。
- aof是追加的数据，如果处于某种问题redis停止工作，不会出现数据丢失情况。
- 当aof文件太大时，redis能够在后台重写aof
- aof以易于理解和解析的格式包含所有操作，可以轻松导出aof文件

**缺点**
- 对于相同的数据集，aof文件通常大于rdb文件
- 根据fsync策略，aof可能比rdb慢

### 8、使用redis实现分布式锁
**加锁**
如果使用SETNX加锁会出现过期后key删除但没有删除锁。

`SET lock_key random_value NX PX 5000`

`random_key`是客户端生成的唯一字符串

`NX`表示只在键不存在时，对键进行设置操作

`PX 5000`设置键的过期时间为5000毫秒

**解锁**
删除key，通常需要先比较value，避免将其他客户端的锁给删除了

### 9、redis的异步队列
使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息时，可以sleep后重试。

不sleep的方式：使用blpop，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。

能否生产一次消费多次？使用pub/sub主题订阅者模式，实现1：N的消息队列。

发布/订阅的缺陷？客户端在执行订阅操作的过程中断网，客户端会丢失断线期间的消息，可以使用专业的消息队列。

延迟队列？使用sortedset，拿时间戳做score，消息内容作为key调用zadd来生产消息，zrangebyscore指令获取N秒之前的数据轮询处理。

### 10、如果有大量的key需要设置同一时间过期，需要注意什么？
如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象，一般需要在时间上加一个随机值，使过期时间分散。

### 11、