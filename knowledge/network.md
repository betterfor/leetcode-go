## 1、七层协议：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层

1、应用层

通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程间的通信和交互的规则。

2、表示层

提供数据格式转化服务，如加密解密、数据压缩等

3、会话层

建立端连接并提供访问验证和会话管理(session)

4、传输层

负责向两台主机进程之间的通信提供通用的数据传输服务，单位数据段
- TCP：面向连接，可靠的数据传输服务
- UDP：无连接的，尽可能数据传输，不保证数据传输的可靠性

|              | UDP                                  | TCP                              |
| ------------ | ------------------------------------ | -------------------------------- |
| 是否连接     | 无连接                               | 面向连接                         |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞机制 | 可靠传输，使用流量控制和拥塞控制 |
| 连接对象个数 | 支持多对多交互通信                   | 只能是一对一通信                 |
| 传输方式     | 面向报文                             | 面向字节流                       |
| 首部开销     | 首部开销小，仅8字节                  | 首部最小20字节，最大60字节       |
| 场景         | 实时应用(直播，视频会议等)           | 要求可靠的传输应用，例如文件传输 |

**运行在`TCP`上的协议**

- HTTP：主要用于普通浏览
- HTTPS：HTTP协议的安全版本
- FTP：用于文本传输
- POP3：收邮件用
- SMTP：用来发送邮件
- TELNET：通过一个终端登陆网络
- SSH：用于加密安全登陆

**运行在`UDP`上的协议**

- BOOTP：用于无盘设备
- NTP：用于网络同步
- DHCP：动态配置IP地址

**运行`TCP`和`UDP`协议上**

- `DNS`：用于完成地址查找，邮件转发等方式。

5、网络层

选择合适的网间路由和交换节点，确保计算机通信的数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和报进行传送。路由器、多层交换机、防火墙等，单位数据包

6、数据链路层

在通信实体间建立数据通信连接，网卡等，单位帧

7、物理层

为数据端设备提供原始比特流的传输的通路。单位比特

## 2、http 400,,401,403,404

- 400，请求报文存在语法错误
- 401，表示发送的请求需要有通过http认证的认证信息
- 403，表示对请求资源的访问被服务器拒绝
- 404，表示在服务器上没有找到请求的资源

## 3、http的历史

**http/0.9**

就只有一个get请求，没有header等描述数据信息的内容，服务器发送完内容后就把tcp链接给关闭了。

**http/1.0**

1、增加了post、put、head等方法

2、增加header和status code相关的内容

3、多字符集支持、多部分发送、权限、缓存等

**http/1.1**

1、支持持久链接keep alive(在建立完请求之后可以不关闭，之后新的请求可以一直在这个连接中发送数据)

2、增加pipeline，可以在同一个链接里发送多个请求，但是服务端对于进来的请求是按照顺序进行数据返回的

3、增加http的头host和命令

**http/2.0**

1、所有数据以二进制传输

2、同一个链接里发送多个请求不再按照顺序来

3、头信息压缩以及推送等提高效率

- 头信息压缩：对header、content-type、accept等字段进行了压缩，减少带宽的使用
- 推送功能：服务器主动向客户端发起数据传输

## 4、http keep-alive

在http早期，每个http请求都要求打开一个tcp socket连接并且使用完就断开tcp连接。

使用keep alive可以改善这种状态，即在一次tcp连接中可以持续发送多份数据而不会断开连接。通过keep-alive机制，可以减少tcp连接建立的次数，也意味着可以减少`TIME_WAIT`状态连接，以此提高性能。

但长时间的tcp连接容易导致系统资源无效占用，设置keep-alive timeout时间。

**http keep-alive与tcp keep-alive**

http的keep-alive是为了让tcp活的更久一点，以便在同一个链接上传送多个http，提高socket的效率

tcp的keep-alive是tcp的一种检测tcp连接状况的保鲜机制。建立连接后，如果客户端一直不发送数据或隔很长时间才发送一次数据，tcp自动发送一个数据为空的报文(侦测包)给对方，如果对方回应了说明在线，如果对方没有回应并且多次重试则关闭连接

[Http长连接和Keep-Alive以及Tcp的Keepalive](https://blog.csdn.net/weixin_37672169/article/details/80283935)

## 5、http能不能一次连接多次请求，不等后端返回

http本质上是socket连接，因此发送请求，写入tcp缓存中，可以多次进行

## 6、三次握手和四次挥手

**TCP报文格式**

![报文](https://gitee.com/zongl/cloudImage/raw/master/images/2021/02/28/报文.jpeg)

1、序号（seq）：4个字节，用来标记数据段的顺序，TCP把连接中发送的所有数据字节都编上一个序号，第一个字节的编码由本地随机产生；给字节编上序号后，就给每个报文段指派一个序号；序号seq就是这个报文段中的第一个字节的数据编号。

2、确认号（ack）：占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；序号表示报文段携带数据的第一个字节的编号；而确认号指的是期望收到下一个字节的编号；因此当前报文段最后一个字节的编号+1为确认号

3、标志位（flags）：

- URG：紧急指针有效
- ACK：确认序号有效
- PSH：接收方应该尽快将这个报文交给应用层
- RST：重置连接
- SYN：发起一个新连接
- FIN：释放一个连接

**三次握手**

![](https://gitee.com/zongl/cloudImage/raw/master/images/2021/02/28/三次握手.png)

- 第一次：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号
- 第二次：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
- 第三次：客户端收到服务器的SYN_ACK包，向服务器发送包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手

**四次挥手**

![](https://gitee.com/zongl/cloudImage/raw/master/images/2021/02/28/四次挥手.png)

- 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN_WAIT-1（终止等待1）状态。*TCP规定，FIN报文段即时不携带数据，也要消耗一个序号*
- 服务器收到连接释放报文，发送确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务器进入CLOSE_WAIT（关闭等待）状态。TCP服务器通知高层的应用程序，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端仍要接受。这个状态还要持续一段时间，也就是整个CLOSE_WAIT状态的持续时间。
- 客户端收到服务器的请求后，此时，客户端就进入FIN_WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后数据）
- 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1,ack=u+1，由于在半关闭状态，服务器很可能又发送一些数据，假定此时序列号为seq=w，此时，服务器就进入了LAST-WAIT（最后确认）状态，等待客户端确认
- 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1,ack=w+1，序列号seq=u+1，此时客户端就进入TIME_WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须等待2 MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
- 服务器只要收到客户端发出的确认，立即进入CLOSED状态。同样，撤销了TCB后，就结束了这次的TCP连接。可以看出，服务器结束TCP连接的时间比客户端早一些。

**为什么连接时三次握手，关闭是四次握手？**

当服务器收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK报文是用来应答的，SYN报文用来同步的。但是关闭连接时，服务器收到FIN报文时，很可能并不会立即关闭socket，所以只能先回复一个ACK报文，只有当客户端所有的报文都发送完了，才能发送FIN报文，因此不能一起发送，需要四次挥手。

**为什么不能两次握手进行连接**

三次握手完成了两个重要的功能，既要双方做好发送数据的准备工作，也要允许双方就初始序列号进行协商，这个序列号在握手的过程中被发送和确认。

如果把三次握手改成两次握手，可能会发生服务器端发送的数据丢失，而服务器端已经在建立连接的阶段，客户端会超时重新发送请求时，服务器会重新开启一个端口连接，造成服务器端开销浪费。

**如果已经建立连接，客户端突然出现故障怎么办**

TCP设有保活计数器，显然，客户端出现故障，服务器不能一直等下去。服务器没收到一次客户端请求就回重新复位这个计数器，时间通常设置为2个小时。若两个小时没有收到客户端的任何数据，服务器就回发送一个探测报文段，以后每隔75秒发送一次。若连发10次探测报文没有反应，服务器就认为客户端出了故障，关闭连接。

**[为什么TIME_WAIT状态需要经过2 MSL（最大报文生存时间）才能返回CLOSE状态](https://zhuanlan.zhihu.com/p/51961509)**

- 保证客户端发送的最后一个ack报文段能够到达服务器。因为最后一个ack确认包可能会丢失，然后服务器会超时重传第三次握手的FIN报文，然后客户端再重传一次第四次挥手的ack报文。如果没有2msl，客户端发送完最后一个ack报文后直接关闭连接，就会接受到一个非法的报文段，返回RST报文，表示拒绝此次通信，然后双方发生异常，服务器就不能按照正常步骤进入CLOSED状态，就会耗费服务器资源
- 在第四次挥手后，经过2msl的时间足以让本地连接产生的所有报文段都消失，这样下一次新的连接中就不会出现旧连接的报文段了。

[[TCP的三次握手与四次挥手理解及面试题（很全面）](https://www.cnblogs.com/bj-mr-li/p/11106390.html)](https://www.cnblogs.com/bj-mr-li/p/11106390.html)

## 7、输入URL到浏览器发生了什么？

1、URL解析：判断输入的是一个合法的URL还是待搜索的关键字

2、DNS解析：DNS查询，=> 8

3、TCP连接：
 - 应用层：发送http请求
 - 传输层：TCP传输报文，三次握手
 - 网络层：IP协议查询mac地址
 - 链路层：以太网协议
 
4、服务器接受和处理请求

![大致流程](https://gitee.com/zongl/cloudImage/raw/master/images/2021/03/01/server_requests.jpg)

5、浏览器接受响应及渲染页面

## 8、DNS基于TCP还是UDP，为什么？

**DNS查询过程的两种方式**

1、递归查询：你找我要一个域名的IP地址，但是我不知道，那我去帮你去向知道的人问这个IP地址。从hosts到本地域名服务器使用

2、迭代查询：你找我要一个域名的IP地址，我也不知道这个IP地址，但是我知道谁知道，我告诉你去找谁问。从本地域名服务器到根域名服务器。

> 浏览器 -> 系统(hosts) -> 路由器 -> ISP(互联网服务提供商) -> 根域名服务器(将管辖范围的顶级域名服务器的ip告诉本地) -> 顶级域名服务器(收到请求后查询区域文件记录，若无将管辖范围内的主域名服务器的ip告诉本地) -> 主域名服务器(收到请求后查询缓存，若没有进入下一级域名服务器查找，重复直到找到) -> 保存结果至缓存

>  UDP报文的最大长度为512字节，而TCP允许报文长度超过512字节。当DNS查询超过512字节时，协议的TC标志出现删除标志，这时则使用TCP发送。

**区域传送使用TCP一般有以下两种考虑**

1、辅域名服务器会定时向主域名服务器进行查询以便了解数据是否有变动。如有变动，则会执行一次区域传送，进行数据同步。**区域传送将使用TCP而不是UDP，是因为数据同步传送的数据量比一个请求和应答的数据量要多得多**

2、TCP是一种可靠的连接，保证了数据的准确性。

**域名解析时使用UDP**

1、客户端向DNS服务器查询域名时，一般返回的内容都不超过512字节，使用UDP传输即可，不用进行TCP三次握手，DNS服务器负载更低，响应更快

2、很多DNS服务器配置时仅支持UDP查询包

[DNS用的是TCP协议还是UDP协议？](https://www.pianshen.com/article/55841377733/)

## 9、rpc和http的区别

http基于传输层的TCP/IP的可靠连接，就是客户端和服务器约定好的一种通信格式。

rpc是远程调用，其对应的是本地调用，其协议通常包括传输协议和序列化协议。

rpc可以使用http协议实现(grpc HTTP2)，也可以同tcp实现(dubbo)，rpc效率更高。

**为什么要用rpc**

rpc调用是因为服务拆分或本身多个服务之间的通信。服务的拆分独立部署，而服务间的调用需要网络通信，用http可以但比较复杂。
使用rpc框架，来屏蔽底层调用细节，使得编码还是和之前的本地调用差不多。
并且http协议比较冗余，rpc是远程调用所以不用考虑通用性。

## 10、TCP粘包

TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接受缓冲区看，后一包的头紧接着前一包的尾。

**原因**

1、发送方的原因

TCP默认使用Nagle算法（作用：减少网络中报文段的数量）：
只有上一个分组得到确认，才会发送下一个分组，收集多个小分组，在一个确认到来时一起发送

2、接收方原因

TCP接受到数据包时，应用层并不会立即处理。实际上，TCP将接收到的数据包保存在接受缓存里，然后应用程序主动从缓存读取收到的分组。
如果TCP接受数据包到缓存的速度大于应用程序从缓存读取数据包的速度，多个包就回被缓存，应用程序就有可能读取到多个首位相邻粘到一起的包。

**处理方法**

1、发送方

关闭Nagle算法，使用TCP_NODELAY选项来关闭算法(发送方不缓存消息)

2、接收方在应用层处理

循环处理，应用程序从接受缓存中读取分组时，读完一条数据就立即读取下一条数据，知道所有数据被处理完成。
发送固定长度的消息；把消息的尺寸和消息一块发送；使用特殊的标记来区分消息间隔(如json)

**UDP会不会有粘包问题呢？**

- TCP：为了保证可靠传输并减少额外开销（每次发包都要确认），采用基于流的传输，是无消息边界的。
 > 消息边界: 传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息
- UDP：面向消息传输，是有消息边界的，接收方每次只接受一条消息，所以不存在粘包问题。

[什么是TCP粘包](https://www.cnblogs.com/cangqinglang/p/11503057.html)
[TCP粘包](https://draveness.me/whys-the-design-tcp-message-frame/)

## 11、描述session、token和cookie，cookie是怎么传输的

http是无状态协议：就是说这一次请求和上一次请求没有任何关系。

**session**

客户端访问服务器，服务器会保存当前对话session相关数据，写入cookie中，下次再收到session_id，找到之前保存的数据，就能得知用户的身份。

缺点：扩展性不好

**Cookie**

类似于令牌，装有sessionID，存储在客户端，浏览器通常会自动添加

**Token**

类似于cookie，无状态，用户信息加密到token，是认证+授权

## 12、如果告诉客户端，响应的是什么数据类型？

Content-Type： 文件类型， text/html，application/json

Content-Disposition： 如果Content-Type为下载类型时，这个信息头会告诉下载文件的名称和类型

## 13、TCP队头阻塞和HTTP队头阻塞

**TCP队头阻塞**

TCP数据包有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包阻塞

**HTTP队头阻塞**

http 1.x采用长连接(Connection：keep-alive)，可以在一个TCP请求上，发送多个http请求

- 非管道化：完全串行执行，请求->执行->请求->执行...，后一个请求必须在前一个响应之后发送
- 管道化：请求可以并行发出，但响应必须串行返回。后一个响应必须在前一个响应之后。是因为没有序号标明顺序，只能串行接受

**管道化请求的缺点**

- 会造成队头阻塞，前一个请求未及时返回，后面的响应被阻塞
- 请求必须是幂等请求（一次请求和多次请求应具有相同的作用），不能修改资源。因为意外终端时，客户端需要把未收到响应的请求重发，非幂等请求会造成资源破坏

**解决方法**

- 并发TCP连接(浏览器一个域名采用6-8个TCP连接，并发HTTP请求)
- 域名分片（多个域名，可以建立更多的TCP连接，从而提高HTTP请求的并发）

[TCP队头阻塞和HTTP队头阻塞](https://www.cnblogs.com/mengff/p/12724641.html)



https://thinkwon.blog.csdn.net/article/details/104903925

## 14、多进程通信(ipc)方式，共享存储区原理

IPC方式有管道、消息队列、信号量、共享存储、socket、streams等

1、管道

- 半双工(数据只能在一个方向流动)，具有固定的读端和写端
- 只能用于具有亲缘关系的进程之间的通信（父子进程或兄弟进程）
- 对于读写两端可以看成是一种特殊的文件，可以使用read、write函数，但只存在于内存之中

2、FIFO(命名管道)

- 可以在无关的进程之间交换数据，与无名管道不同
- 有路径名与之相关联，以一种特殊设备文件形式存在于文件系统中

3、消息队列

是消息的链接表，存放在内核中。一个消息队列由一个标识符来标识
- 面向记录，其中消息具有特定的格式以及特定的优先级
- 独立于发送与接收进程。进程终止时，消息队列及其内容不会被删除

4、信号量

是一个计数器。用于实现进程间的互斥和同步，而不是用于存储进程间的通信数据。
- 用于进程间同步，若要在进程间传递数据需要结合共享内存
- 基于操作系统的pv操作，程序对信号量的操作都是原子操作
- 每次对信号量的pv操作不仅限于对信号量加1或减1，而且可以加减任意整数
- 支持信号量组

5、共享内存

- 是最快的一种ipc，因为进程是直接对内存进行存取
- 因为多个进程可以同时操作，所以需要进行同步
- 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问