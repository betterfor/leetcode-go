## 1、docker 核心原理

**限制的视图namespace**

| namespace | 隔离内容                   |
| --------- | -------------------------- |
| IPC       | 信号量、消息队列和共享内存 |
| Network   | 网络设备、网络栈、端口等   |
| Mount     | 挂载点(文件系统)           |
| PID       | 进程编号                   |
| User      | 用户和用户组               |
| UTC       | 主机名和域名               |

**限制资源cgroups：包括cpu、内存、磁盘、网络带宽等**

- cpu，cpu.cfs_quota_us容量，cpu.cfs_period_us设置使用量
- blkio，为块设备设定I/O限制，一般用于磁盘
- cpuset，为进程分配独立的cpu核和对应的内存节点
- memory，内存

将被限制的进程PID写入tasks文件，上面的设置就会对进程生效了

**rootfs**

`chroot`:change root file system。改变进程的根目录到你指定的目录

1、启动linux namespace配置
2、设置指定的cgroups参数
3、切换进程的根目录

rootfs只是一个操作系统所包含的文件、配置和目录，并不包括操作系统

**UFS(Union File System)联合文件系统**

层（layer）：用户制作镜像的每一个操作，都会生成一个层，也就是一个增量rootfs

UnionFS主要功能是将多个不同位置的目录联合挂载到同一个目录下。`mount -t aufs`

容器的rootfs

- 可读层：挂载方式是只读，`readonly+whiteout`.都以增量的方式包含了操作系统的一部分
- 可读写层： rw，在没写入文件之前，这个目录是空的。而一旦在容器里做了写操作，修改的内容会以增量的方式出现在这个层中。
可以使用docker commit和push指令，保存这个被修改过的可读写层，原先的只读层不会有任何变化。（为了实现删除可读层里的文件删除操作，aufs会创建一个whiteout文件，把只读层文件“遮挡”起来）
- Init层：docker项目单独生成的内部层，专门用来存放/etc/hosts,/etc/resolv.conf等信息，这些文件本来属于只读层，
但是用户需要在容器启动时写入一些指定的值比如hostname，这些修改只对当前容器生效，我们不希望在docker commit时把信息连同读写层一起提交掉。

## 2、pivot_root和chroot的区别
pivot_root主要是把整个系统切换到一个新的root目录，而移除对之前root文件系统的依赖，这样你能够umount原先的root文件系统。
chroot是针对进程，而系统的其他部分仍运行在老的root目录

## 3、Dockerfile内容
- FROM：指定基础镜像
- MAINTAINER：维护者信息
- RUN：构建镜像时执行的命令
- ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不能解压)
- COPY：类似于ADD，但不能自动解压文件，也不能访问网络资源
- CMD：容器启动后调用，在`docker run`时运行
- ENTRYPOINT：类似于CMD，但不会被`docker run`的命令行参数的指令覆盖
- LABLE：为镜像添加元数据
- ENV：环境变量
- ARG：构建参数，仅在`docker build`有效，构建好的镜像不存在此环境变量
- VOLUME：持久化目录
= EXPOSE：外界交互端口
- WORKDIR：工作目录
- USER：执行后续命令的用户和用户组
- HEALTHCHECK：健康检查
- ONBUILD：延迟构建命令，有新的Dockerfile使用之前的镜像会执行ONBUILD命令

## 4、优化Dockerfile
- 构建顺序影响缓存利用率。
把不需要经常更改的行放在最前面，更改频繁的行放在最后面
- 只拷贝文件，防止溢出
- 最小化可缓存的执行层，每一个`RUN`指令都被看作可缓存的执行单元，太多的`RUN`指令会增加镜像层数，增大体积。
将更新缓存和安装文件放在同一个`RUN`指令中。
- 减小镜像体积：删除不必要的依赖 `apt --no-install-recommends`；删除包管理工具缓存
- 使用多阶段构建

## 5、docker load 加载一个镜像，docker images查看不到的原因


## 6、docker后端存储

**存储驱动**

1、 AUFS是一种Union FS，是文件级的存储驱动。AUFS能覆盖一或多个现有文件系统的层状文件系统，
把多层合并成文件系统的单层显示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。
这种文件系统可以一层一层地叠加修改文件。无论底下有多少层都是只读的，只有最上层的文件系统是可写的。

- 优点：性能稳定，测试完善，适用场景丰富
- 缺点：只在ubuntu和Debian，没有进内核

2、 Overlay： 一个upper文件系统和一个lower文件系统，代表Docker的镜像层和容器层

- 优点：合并进内核
- 缺点：硬连接的方式会引发inode耗尽的问题，整体不成熟

3、 Device mapper：从逻辑设备到物理设备的映射框架机制，在设备创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，
而容器是镜像的快照。所以在容器里看到文件系统是资源池上基本的文件系统的快照，并不为容器分配空间。 块级存储

- 优点：基于块设备而不是基于文件，会拥有一些内置的能力如配额支持
- 缺点：没有入门的支持

4、 Btrfs：下一代写时复制文件系统，文件级存储，把文件系统一部分配置为一个完整的子文件系统，称为subvolume。一个大的文件系统可以被划分为多个文件系统，
这些子文件系统共享底层的设备空间

- 优点：比较健壮，收到良好支持
- 缺点：没有成为linux发行版的主流选择

5、ZFS：使用zfs驱动需要有ZFS格式化的块设备挂载到graphdriver路径（默认/var/lib/docker）,以快照的克隆作为分享层的途径。它不是基于文件的实现。

- 优点：拥有较好的性能，有配额的支持
- 缺点：没有基于文件(inode)的共享达到内库共享

[docker 面试](https://www.jianshu.com/p/2de643caefc1)

## 7、docker预热

没有平台之前，运维人员安装微服务的时候，需要先拉取镜像传到内网，然后再执行安装
