## 1、数据库三大范式
- 第一范式：数据库的每一个字段都是不可分割的
- 第二范式：数据库表中的非主属性只依赖于主键
- 第三范式：不存在非主属性对关键字的传递函数依赖关系

## 2、事务实现原理
**定义**

事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果从一种一致性状态变到另一种一致性状态。

**四大特性ACID**

- 原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用。

  Innodb实现回滚靠的是undo log：当事务对数据库进行修改时，Innodb会生成对应的undo log；
  如果事务执行失败或调用rollback，导致事务需要回滚，便可利用undo log中的信息将数据回滚到修改之前的样子。
  undo log属于逻辑日志，记录的是sql执行的相关信息。当发生回滚时，Innodb会根据undo log的内容做与之前相反的工作。
  
- 持久性：一个事务被提交之后，它对数据库中数据的改变是持久的，即时数据库发生故障也不应该对其有任何影响

  Innodb作为mysql的存储引擎，数据是存放在磁盘中的，但如果每次读写都是需要磁盘IO，效率会很低。
  为此，Innodb提供缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲。
  如果mysql宕机，buffer pool的数据没有更新到磁盘会导致数据的丢失。所以引入redo log。
  当数据修改时，除了修改Buffer log中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync对redo log进行刷盘。
  如果mysql宕机，重启时可以读取redo log中的数据对数据库进行恢复。而所有的修改先写入日志再更新到buffer pool，保证了数据不会因为mysql宕机而丢失
  
  **既然redo log也需要在事务提交将日志写入磁盘，为什么比直接将buffer log修改的数据写入磁盘(刷脏)更快？**
  
  * 刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，是顺序IO
  * 刷脏是以数据页为单位，mysql默认页大小是16kb，一个page上的小修改都需要整页写入；redo log只包含真正写入的部分，无效IO大大减少
  
  **redo log和binlog**
  
  - 作用不同：redo log是故障恢复，保证mysql宕机不会影响持久性；binlog可基于时间点恢复数据、主从复制
  - 层次不同：redo log是Innodb存储引擎实现的，binlog是mysql的服务器层实现的
  - 内容不同：redo log是物理日志，内容基于磁盘的页；binlog是二进制，可能是sql语句、数据或两者
  - 写入时机不同：redo log在事务提交时写入，binlog的写入时间相对多元
  
- 隔离性：并发访问数据库时，一个用户的事物不被其他事务所干扰，各并发事务之间数据库时独立的。

  主要是两个事务的写操作之间的相互影响。来看并发情况下，读操作可能存在的问题：
  * 脏读：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个事务rollback，则后一个事务所读取的数据就会是不正确的
  * 不可重复读：在一个事务的两次查询中数据不一致，这可能是两次查询过程中插入了一个事务更新的原有数据
  * 幻读：在一个事务的两次查询数据的个数不一样，多出了几列原先没有的数据
  
  **事务的隔离级别** 一般来说，隔离级别越低，可支持的并发越高，但隔离性越差。Innodb默认的隔离级别是RR
  
  | 隔离级别                  | 脏读 | 不可重复读 | 幻读 |
  | ------------------------- | ---- | ---------- | ---- |
  | Read Uncommitted 读未提交 | √    | √          | √    |
  | Read Committed 读已提交   | ×    | √          | √    |
  | Repeatable Read可重复读   | ×    | ×          | √    |
  | Serializable 可串行化     | ×    | ×          | ×    |
  
  **Innodb实现的MVCC避免了幻读问题** 在同一时刻，不同事务读取到的数据可能是不同的(即多版本)
  
  MVCC最大的优点是读不加锁，因此读写不冲突，并发性能好。Innodb实现MVCC，多个版本数据可以共存
  - 隐藏列：Innodb中每行数据都有隐藏列，隐藏列中包含了本行的事务id，指向undo log的指针等
  - 基于undo log的版本链：每条undo log会指向更早版本的undo log，从而形成一条版本链
  - ReadView：通过隐藏列和版本链，mysql可以将数据恢复到指定版本，但要具体恢复到哪个版本，需要根据readview来确定。
  
- 一致性：执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的
  
  

[深入理解mysql事务](https://www.cnblogs.com/kismetv/p/10331633.html)

## 3、数据库如何建索引

`alter table table_name add [primary key/unique/index index_name/fulltext]  (column)`

1、主键索引：在给一个字段设置主键时，会自动创建主键索引，用来确保每个值都是唯一的

2、唯一索引：在创建唯一索引要不能给具有相同的索引值

3、普通索引：结构主要以B+数和哈希索引为主，主要是对数据表的数据进行精确查找

4、全文索引：搜索数据表中的字段是否包含搜索的关键字

5、组合索引：多个列组成一个索引 `index index_name (colume1,colume2...)`。
如果想要命中联合索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。一般情况下，将查询需求频繁或字段选择性高的列放在前面。

**B+树**

特点：
- 平衡的多叉查找树
- 有n棵子树的节点含有n个关键字
- 所有的关键字全部存储在叶子结点上，且叶子结点根据自身关键字自小而大顺序连接
- 非叶子结点可以看成索引部分，节点中仅包含其子树的最大(最小)关键字

1、为什么不用哈希索引？

- 哈希索引不支持使用索引排序
- 不支持模糊查询及多列索引的最左前缀匹配
- 哈希索引虽然在等值查询比较快，但不稳定，性能不可预测，当某个键值存在大量重复的时候会发生哈希碰撞。

2、为什么不用红黑树或二叉排序树？

树的查询时间和树的高度有关，B+树是一棵多路搜索树可以降低树的高度，提高查找效率

3、既然增加树的路数可以降低树的高度，那无限增加树的路数是不是最优查找效率？

这样会形成有序数组，文件系统和数据库索引都是存在硬盘上的，如果数据量大的话，不一定能一次性加载到内存中。而B+数可以加载一个节点查找数据

4、为什么不用B树？

- B+树中间节点不保存数据，所以一次访问磁盘页能容纳更多数据
- B+树必须查找到叶子结点，B树只要匹配到可以不管元素位置，因此B+树更稳定
- 对于范围查找来说，B+树可以遍历叶子结点，而B树需要重复中序遍历

**创建索引原则**

- 最左前缀匹配，查询条件的顺序
- 较频繁的查询条件字段
- 更新频繁的字段不适合创建索引
- 若不能有效区分数据的列不适合做索引列
- 尽量扩展索引，不要新建索引。比如已经有了a的索引，要新加(a,b)的索引，那么只需要修改原来的索引
- 定义有外键的数据列一定要创建索引
- 对于查询中很少涉及的列，重复值比较多的列不要创建索引
- 对于定义为text、image和bit的数据类型的列不要创建索引

**创建索引的注意事项**
- 非空字段：应指定列为Not Null。
- 取值离散打的字段
- 索引字段越小越好

## 4、mysql百万级别或以上的数据如何删除

由于索引需要额外的维护成本，当我们对数据增加、修改、删除时都会额外的产生对索引文件的操作，这些操作都需要消耗额外的IO，会降低执行效率。
在我们删除数据库百万级别数据的时候，删除数据的速度和创建的索引数量是成正比的。

1、先删除索引

2、删除其中无用的数据

3、删除完成后重新创建索引

4、比直接删除速度快很多，更别说万一删除中断，删除操作需要回滚。

## 5、mysql索引
- 优点：加快数据检索速度；通过使用索引，可以在查询过程中，优化隐藏器，提高系统性能
- 缺点：创建和维护索引要耗费时间，占用物理空间

**索引算法**

- BTree算法：默认算法，支持不等操作上
- 哈希算法：只能用于对等比较

## 7、有关权限的表
- user权限表：记录允许连接到服务器的用户账号信息，里面的权限是全局的
- db权限表：记录每个账号在各个数据库的操作权限
- table_priv权限表：记录数据表级的操作权限
- columns_priv权限表：记录数据列级的权限操作
- host权限表：配合db权限表对给定主机上数据库操作权限更细致的控制

## 8、mysql的binlog？
**使用场景**

- mysql主从复制：master端开启binlog，master把binlog传递给slaves来达到数据一致
- 数据恢复：使用mysqlbinlog工具恢复数据

**启用binlog**

设置`SET SQL_LOG_BIN=1`来启用binlog

**录入格式 binlog_format**
- statement：每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少binlog的日志量，节约了IO，提高性能。
由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
- row级别：不记录sql语句的上下文相关信息，仅保存哪条记录被修改。
记录单元每一行的改动，基本可以全部记录下来，但由于很多操作会导致大量行改动，因此文件保存的信息太多，日志量太大。
- mixed：普通操作用statement，无法使用的时候用row

[mysql binlog介绍](https://blog.csdn.net/wwwdc1012/article/details/88373440)

## 9、存储引擎
常用的存储引擎有：
- Innodb：提供对数据库ACID事务的支持，并提供行级锁和外键的约束
- MyISAM：不提供事务，不支持行级锁和外键
- MEMORY：所有数据在内存中，数据处理速度快，但安全不高

**MyISAM和Innodb的区别**

|                        | MyISAM                                                       | Innodb                                                       |
| ---------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储结构               | 每张表存放在三个文件中：frm-表格定义，MYD-数据文件，MYI索引文件 | 所有表都保存在同一个数据文件中，大小受限于操作系统个，一般为2GB |
| 存储空间               | 可被压缩，存储空间小                                         | 需要更多的内存和存储，会在内存中建立专用的缓冲池用于高速缓冲数据和索引 |
| 可移植性、备份及恢复   | 以文件形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复可针对某个表进行操作 | 免费的方案是拷贝数据文件、备份binlog，或mysqldump，但数据大时速度慢 |
| 文件格式               | 数据.MYD,索引.MYI                                            | 数据和索引集中存储.IBD                                       |
| 记录存储顺序           | 按插入顺序保存                                               | 按主键大小有序插入                                           |
| 外键                   | 不支持                                                       | 支持                                                         |
| 事务                   | 不支持                                                       | 支持                                                         |
| 锁                     | 表级锁                                                       | 行级锁，表级锁，锁定力度小并发高                             |
| select                 | 性能更优                                                     |                                                              |
| insert，update，delete |                                                              | 性能更优                                                     |
| select count(*)        | 更快，因为内部维护了一个计数器，可以直接调取                 |                                                              |
| 索引实现方式           | B+树索引，是堆表                                             | B+树索引，是索引组织表                                       |
| 哈希索引               | 不支持                                                       | 支持                                                         |
| 全文索引               | 支持                                                         | 不支持                                                       |

**MyISAM和Innodb索引的区别**

- Innodb索引是聚簇索引，MyISAM是非聚簇索引
- Innodb主键索引的叶子结点存储行数据，因此主键索引高效
- MyISAM索引的叶子结点存储的是行数据地址，需要再寻址一次才能找到数据
- Innodb非主键索引的叶子结点存储的是主键和其他索引的列数据，因此查询时做到覆盖索引会非常高效。

## 10、聚簇索引和非聚簇索引
- 聚簇索引：将数据存储和索引放在一块，找到了索引就找到了数据
- 非聚簇索引：将数据存储与索引分开结构，索引结构的叶子结点指向了数据的对应行，MyISAM通过key_buffer把索引先缓存到内存中，
当需要访问数据（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘对应数据，这也是为什么索引不在key_buffer命中时，速度慢的原因

## 11、锁
**锁机制**

- 共享锁(读锁)：其他事务可以读，不能写
- 排他锁(写锁)：其他事务不能读，也不能写

**锁粒度**

- MyISAM和MEMORY存储引擎采用的是*表级锁*
- BDB存储引擎采用的是*页面锁*
- Innodb存储引擎既支持*行级锁*，也支持*表级锁*，但默认是*行级锁*。

**不同锁粒度比较**

- 表级锁：开销小，加锁快；锁粒度大，发生锁冲突的概率最高，并发度最低
  * 总是一次性同时获取所有需要的锁以及同时按相同的顺序获取表锁来避免死锁
  * 更适合查询为主，并发用户少
- 行级锁：开销大，加锁慢；会出现死锁，锁粒度最小，发生锁冲突的概率最低，并发度最高
  * 最大程度的支持并发，同时也带来最大的锁开销
  * 在Innodb中，除单个sql组成的事务外，锁是逐步获得的，可能发生死锁
  * 在存储引擎层实现，适合大量按索引条件并发更新少量不同数据，同时又有并发查询的应用
- 页面锁：开销和加锁时间介于表锁和行锁之间；会出现死锁；粒度介于表锁和行锁之间，并发度一般。

**MyISAM表锁**

- 表共享读锁：不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求
- 表独占写锁：会阻塞其他用户对同一表的读和写操作。

当一个线程获得对一个表的写锁后，只有持有锁的线程可以对表进行更新。其他线程的读写操作会等待，直到锁被释放为止。
默认情况下，写锁比读锁具有更高的优先级：当一个锁释放时，这个锁会优先给写锁队列中等待的获取锁请求，然后再给读锁队列中等待的获取锁请求。

这也是MyISAM表不适合有大量更新和查询操作的原因。因为大量的更新操作会造成查询操作很难获得读锁，从而可能阻塞；长时间的读操作也会使写操作‘饿死’。

在执行查询操作前，会自动给表加读锁；在更新操作前，会自动给表加写锁。

**Innodb行级锁和表级锁**

- 行锁
  * 共享锁(S)：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁
  * 排他锁(X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
- 表锁
  * 意向共享锁(IS)：事务打算给数据行加共享锁，事务在给一个数据行前加共享锁前必须先取得该表的IS
  * 意向排他锁(IX)：事务打算给数据行加排他锁，事务在给一个数据行前加排他锁前必须先获得改表的IX
  

**Innodb加锁方法**

- 意向锁是Innodb自动加的
- 对于更新操作，Innodb会自动给设计数据集加排他锁(X)
- 对于普通select，Innodb不会加任何锁
- 事务可以通过一下语句显示添加锁(基于索引)
  * 共享锁：`select * from table_name where ... lock in share mode`
  * 排他锁：`select * from table_name where id=1 for update`.
  `for update`可以根据条件来完成行锁锁定，并且id是有索引键的列。 如果id不是索引键，那么Innodb将完成表锁，无法并发
  

**Innodb存储引擎的锁算法**
- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap锁定一个范围，包括记录本身

Innodb对于行查询使用next-key lock,是为了解决幻读问题。当查询的索引含有唯一属性时，将next-key lock降级为record key。而gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内。

**死锁**

- 产生：两个或多个事务在同一资源相互占用，并请求锁定对方的资源，从而导致恶性循环的线性。
- 检测：数据库系统实现了各种死锁检测和死锁超时机制。Innodb存储引擎能检测到死锁的循环依赖并立即返回错误。
- 恢复：死锁发生后，只有部分或完全回滚其中一个事务，才能打破死锁。
- MyISAM避免死锁：不会出现
- Innodb避免死锁：
  * 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表
  * 在同一事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生的概率
  * 对于非常容易发生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表锁来减少死锁发生
  * 如果业务处理不好可以使用分布式事务锁或乐观锁
  

**乐观锁和悲观锁**
- 乐观锁：假设不会发生并发冲突，只有在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来锁定
  * 实现方式：一般使用版本号机制或CAS算法实现
  * 场景：写比较少，多读
- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，知道提交事务。
  * 实现方式：使用数据库的锁机制
  * 场景：多写

[mysql锁总结](https://zhuanlan.zhihu.com/p/29150809)

## 12、视图
本质上是一个虚拟表，在物理上不存在，内容与真实表相似，但并不在数据库以存储的数据值形式存在。

特点：
 - 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系
 - 视图是由基本表(实表)产生的表(虚表)
 - 视图的建立和删除不影响基本表
 - 对视图内容的更新直接影响基本表
 - 当视图来自多个基本表时，不允许添加和删除数据

用途：简化sql查询，提高开发效率，兼容老的表结构

优点：
 - 查询简单，简化操作
 - 数据安全性
 - 逻辑数据独立性

缺点：
 - 性能：数据库必须把视图的查询转化为对基本表的查询，如果这个视图是由一个复杂度的多表查询定义的，那么即使是视图的一个简单查询，数据库也把他变成一个复杂的结合体，需要花费时间
 - 修改限制

## 13、存储过程和函数
存储过程是一个预编译的sql语句

优点：
 - 存储过程是预编译的，执行效率高
 - 存储过程的代码直接存放在数据库中，通过存储过程名直接调用，减少网络通讯
 - 安全性高，执行存储过程需要有一定权限的用户
 - 存储过程可以重复使用，减少数据库开发人员工作量

缺点：
 - 往往定制化于特定的数据库上，因为支持的编程语言不同。当切换到其他厂商的数据库系统时，需要重写原有的存储过程。
 - 存储过程的性能调校与撰写，受限于各种数据库系统。

## 14、触发器
用户定义在关系表上的一类由时间驱动的特殊**存储过程**。

场景：可以生成某些业务编号；实时监控某张表某个字段的更改

触发器：before insert;after insert;before update;after insert;before delete;after delete

## 15、约束
- not null：用于控制字段的内容一定不能为空
- unique：控件字段内容不能重复，一个表允许有多个unique约束
- primary key：控件字段内容不能重复，一张表只能出现一次
- foreign key：用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。
- check：用于控制字段范围

## 16、in和exist区别
- 如果查询的两个表大小相当，使用in和exist差别不大
- 如果两个表一个较小，一个是大表，那子查询表大的用exist，子查询表小的用in
- not in和not exist：如果查询语句使用not in，那么内外表都进行全表扫描，没有用到索引；而not exist能用到表上的索引，所以not exist比not int快

## 17、varchar和char的区别
**char**
- char表示定长字符串，长度固定
- 如果插入的数据小于char的固定长度时，用空格填充
- 如果长度固定，所以存取速度比varchar快，但占用空间多，是空间换时间的做法
- 最多能存放的字符为255个

**varchar**
- 可变字符串，长度可变
- 插入的数据多长，就按多长来存储
- 存取慢，不占据多余空间，时间换空间
- 最多能存放2^16^=65532

## 18、drop、delete、truncate的区别

> ddl：数据库定义语言，用来创建数据库中的表、索引、视图、存储过程、触发器等
>
> dml：数据操纵语言，如查询，更新，select、insert、update、delete等

|          | delete                               | truncate                     | drop                                             |
| -------- | ------------------------------------ | ---------------------------- | ------------------------------------------------ |
| 类型     | dml                                  | ddl                          | ddl                                              |
| 回滚     | 可回滚                               | 不可回滚                     | 不可回滚                                         |
| 删除内容 | 表结构还在，删除表的全部或部分数据行 | 表结构还在，删除表中所有数据 | 从数据库删除表，所有的数据行，索引和权限也会删除 |
| 删除速度 | 删除速度慢，需要逐行删除             | 删除速度快                   | 删除速度最快                                     |

## 19、数据库优化
1、如何定位及优化sql语句性能问题？explain

2、sql的生命周期
  - 应用服务器与数据库服务器建立连接
  - 数据库进程拿到请求sql
  - 解析并生成执行计划，执行
  - 读取数据到内存并进行逻辑处理
  - 发送结果到客户端
  - 关掉连接，释放资源
  
3、大表数据查询优化

  - 优化表结构schema、sql语句+索引
  - 加缓存，redis，memcached
  - 主从复制，读写分离
  - 垂直拆分，切分系统
  - 水平拆分
  
4、慢查询日志

用于记录执行时间超过某个临界值的sql日志，用于快速定位慢查询。

`set slow_query_log=1;set long_query_time=3;`

5、慢查询优化
- 分析语句，查看是否加载额外的数据，可能是查询了多余的行并且抛弃了，可能是加载了结果不需要的列，对语句进行分析与重写
- 分析语句的执行计划，然后获得其索引的使用情况，之后修改语句或修改索引，使得语句可以尽可能命中索引
- 如果对语句的优化无法进行，可以考虑表中数据是否太大，可以进行横向或纵向拆分表

6、优化查询过程中的数据访问
- 访问数据太多查询性能下降，使用limit限制
- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列，指定列名
- 确认是否需要不必要的行，避免使用`select *`
- 重复查询相同的数据，使用缓存
- 使用explain分析

7、优化长难查询语句
- 将一个大查询分为多个小查询
- 一次性删除大量数据比多次删除少量数据更快
- 分解关联查询，让缓存效率更高

8、为什么要优化数据库
- 系统的吞吐量瓶颈往往出现在数据库的访问速度上
- 随着程序的运行，数据库中的数据会越来越多，处理时间会变慢
- 数据存放在磁盘上，读写速度无法和内存相比

9、数据库结构优化
- 将字段很多的表拆分成多个表
- 增加中间表
- 合理增加冗余字段

## 20、如果mysql数据库cpu飙升怎么处理？
1、先通过top查看是否是mysqld占用导致的；
2、`show processlist;`查询里面跑的session情况，是否有消耗资源的sql在运行；
3、kill线程，调整参数(添加索引、改sql、改内存等)
4、可能是大量session，限制连接数

## 21、主从复制
将数据库中的ddl和dml操作通过binlog传输到从数据库上，然后让这些日志重新执行，从而使从数据库和写数据库保持一致

**作用**
- 主数据库出现问题，可以切换到从数据库
- 可以进行数据库层面的读写分离
- 可以在从数据库进行日常备份

## 22、sql的select语句的完整执行顺序
1、from子句组装不同数据源的数据
2、where子句基于指定的条件对记录进行筛选
3、group by子句将数据划分为多个分组
4、使用聚集函数进行计算,avg,sum...
5、使用having子句筛选分组
6、select计算所有的表达式
7、使用order by对结果集进行排序
8、limit

## 23、union和union all效率
其实都是表连接中结果集的连接，不同之处在于union会去除两个结果集相同的值，而union all不会。所以union all通常效率更高

## 24、为什么不建议使用查询缓存？
查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。
因此很可能你费劲的把结果存起来，还没使用呢，就被更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率非常低。
除非你的业务就是有一张静态表，很长时间更新一次。

## 25、分布式事务实现原理
[](https://draveness.me/distributed-transaction-principle/)