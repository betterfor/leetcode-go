#### 1、
下面这段代码输出的内容
```go
package main

import "fmt"

func main() {
	defer_call()
}

func defer_call() {
	defer func() {fmt.Println("打印前")}()
	defer func() {fmt.Println("打印中")}()
	defer func() {fmt.Println("打印后")}()
	panic("触发异常")
}
```
答案：
```
打印后
打印中
打印前
panic: 出发异常
```
解析：defer的执行顺序是后进先出。当出现panic语句的时候，会先按照defer的后进先出的顺序执行，最后才会执行panic。

#### 2、
下面这段代码输出什么？说明原因。
```go
package main

import "fmt"

func main() {
	slice := []int{0,1,2,3}
	m := make(map[int]*int)

	for key, val := range slice {
		m[key] = &val
	}
	for k, v := range m {
		fmt.Println(k,"->",*v)
	}
}
```
答案：
```
2 -> 3
3 -> 3
0 -> 3
1 -> 3
```
解析：for range循环的时候会**创建每个元素的副本，而不是元素的引用**，所以 m[key] = &val 取的都是变量 val 的地址，所以最后map中所有的元素都是 val 的地址。
正确写法：
```go
package main

import "fmt"

func main() {
	slice := []int{0,1,2,3}
	m := make(map[int]*int)

	for key, val := range slice {
		value := val
		m[key] = &value
	}
	for k, v := range m {
		fmt.Println(k,"->",*v)
	}
}
```

#### 3、
下面两端代码输出什么？
```go
// 1、
func main() {
	s := make([]int,5)
	s = append(s,1,2,3)
	fmt.Println(s)
}
// 2、
func main() {
	s := make([]int,0)
	s = append(s,1,2,3,4)
	fmt.Println(s)
}
```
答案：
```
// 1、[0,0,0,0,0,1,2,3]
// 2、[1,2,3,4]
```
解析：
考点是 append 向 slice 添加元素。

#### 4、
下面这段代码有什么缺陷？
```go
func funcMui(x, y int) (sum int, error) {
	return x+y,nil
}
```
答案：第二个返回值没有命名
解析：在函数有多个返回值时，只要有一个返回值有命名，其他的也必须命名。如果有多个返回值，必须加()；如果只有一个返回值且有命名，也需要加()。
```go
// 正确写法
func funcMui(x, y int) (sum int, err error) {
	return x+y,nil
}
```

#### 5、new() 和 make() 的区别
答案：new(T) 和 make(T) 是Go语言内建函数，用来分配内存，但适用的类型不同。
new(T) 会为 T 类型的新值分配已置0的内存空间，并返回地址（指针），即 *T 的值。换句话说，就是返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。
make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，是经过初始化之后的T的引用。只适用于slice、map和channel。

#### 6、
下面这段代码能否通过编译？不能的话原因是什么；能的话输出结果是什么。
```go
func main() {
	list := new([]int)
	list = append(list,1)
	fmt.Println(list)
}
```  
答案：不能通过编译，new([]int)之后的list是一个*[]int类型的指针，不能对指针进行append操作。可以使用make()初始化之后再操作。

#### 7、
下面这段代码能否通过编译？不能的话原因是什么；能的话输出结果是什么。
```go
func main() {
	s1 := []int{1,2,3}
	s2 := []int{4,5}
	s1 = append(s1, s2)
	fmt.Println(s1)
}
```
答案：不能通过编译。append的第二个参数不能直接使用slice，	s1 = append(s1, s2...)，使用...操作符，将一个切边追加到另一个切片上，或者直接跟上元素，	s1 = append(s1, 1,2,3)

#### 8、
下面这段代码能否通过编译？不能的话原因是什么；能的话输出结果是什么。
```go
var (
	size := 1024
	max_size = size * 2
)

func main() {
	fmt.Println(size,max_size)
}
```
答案：不能通过编译。考点是变量声明的简短形式。形如：
x:=100  限制条件：
- 必须使用显示初始化
- 不能提供数据类型，编译器会自动推导
- 只能在函数内部使用

#### 9、
下面这段代码能否通过编译？不能的话原因是什么；能的话输出结果是什么。
```go
func main() {
	sn1 := struct {
		age  int
		name string
	}{age: 11, name: "qq"}
	sn2 := struct {
		age  int
		name string
	}{age: 11, name: "qq"}

	if sn1 == sn2 {
		fmt.Println("sn1 == sn2")
	}

	sm1 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{"a": "1"}}
	sm2 := struct {
		age int
		m   map[string]string
	}{age: 11, m: map[string]string{"a": "1"}}

	if sm1 == sm2 {
		fmt.Println("sm1 == sm2")
	}
}
```
答案：编译不通过，invalid operation: sm1 == sm2
这道题考的是**结构体的比较**，注意点：
1、结构体只能比较是否相等，不能比较大小。
2、相同类型的结构体才能比较，结构体是否相同不仅与属性类型有关，还与属性顺序有关，sn3和sn1就是不同的结构体
```
sn3 := struct {
		name  int
		age string
	}{age: 11, name: "qq"}
```
3、如果struct的所有成员都可以比较，则比较时逐项比较，如果每一项都相等，两个结构体才相等。
什么是可以比较的呢？常见的bool、数值型、字符、指针、数组等；像切片、map、函数等都是不能比较的。![详情](http://docs.studygolang.com/ref/spec#Comparison_operators)

#### 10、
通过指针变量 *p* 访问其成员变量 *name*，有哪几种方式？
- A.p.name
- B.(&p).name
- C.(*p).name
- D.p->name
答案：AC，& 取址运算符，* 指针解引用

#### 11、
